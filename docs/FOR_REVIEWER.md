# 리뷰어 분들께

안녕하세요, 백엔드 6기 백엔드 지원자 jdohun 입니다.

제 코드를 리뷰해 주러 오신 분들이 보다 편하게 리뷰에 집중하실 수 있도록
저의 어플리케이션에 대한 조금의 가이드를 드리고자 해당 글을 작성합니다.

## 디렉토리 구조

각각의 관심사와 형태 그리고 역할을 기준으로 책임을 분리하고, 각각의 책임에 따라 별도의 디렉토리를 부여하였습니다.

### 도메인

도메인 로직을 구분하는 기준은 `현실 문제에 대한 의사결정 여부` 입니다.

- 정보를 저장하고 현실 세계에 필요한 정보를 계산하는 기능 : `model`
    - 그 중에서도 `class` 와 `enums` 로 구분

- 프로모션에 대한 관심 : `promotion`
    - 전략들을 사용 : `context`

    - 프로모션 전략들 : `strategy`
        - 날짜 확인
        - 총금액 확인
        - 할인 금액 계산

    - 비슷한 형태의 전략을 사용하는 `context`들을 관리하는 : `enums`

### DTO

- 단순히 값을 저장, 반환한다면 : `dto`
    - 따라서 현실 세계의 문제 미리보기에 필요한 프로모션 결과를 저장하지만
      - 단순히 값을 반환하기만하는 `ChristmasPromotionPreview`은 미리보기 라는 현실 세계는 dto 에 속하게 됩니다.

### Parser

입력된 값의 형식을 검증함과 동시에 `model` 생성에 적절한 형태의 source 로 parsing 합니다. 

### 입출력

- 입력을 위한 가이드 메시지 출력과 입력 값을 리턴의 책임을 갖는 `InputView`
  - 가장 기본적인 Input 에 대한 검증 기능을 가진 `InputValidator`
- 사용자의 입력과 별도로 필수 출력 메시지에 대한 책임을 갖는 `OutputView`
- 미리보기 출력에 대한 책임을 갖는 `Preview`
- 예외 처리된 IllegalArgumentException 의 정보를 출력하기 위한 `IllegalArgumentErrorView`

## 구현 관련 고민 목록

아래에는 제가 이번 어플리케이션을 구현하는 동안 해결하지 못했던 고민들입니다.
참고하시어 편하게 의견을 주신다면 정말 감사하겠습니다!
아래와 관련된 내용이 아니더라도 저의 코드에 대한 다양한 의견, 질문은 언제나 환영입니다!!!

### 좀 더 명확한 패키징 방법

공통된 기능을 추상화한 Interface 와 이를 구현한 클래스를 구분하기 위해
공통 패키지 하위에 `impl`로 구분 지었지만
함수형 인터페이스는 어디에 패키징 되어야 찾아보기 편할지 고민했습니다.
단순히 util 로 묶어서 패키징 할 수도 있었겠지만
util 로 묶은 기능들이 과연 진짜로 `util` 한 가? 에 대한 질문에 해답이 되지 않았습니다.
따라서 저는 추상화한 Interface 와 이를 구현한 클래스들을 가까이 두는 방식이 가장 적절하다고 생각하여


### enum 내부에서 : 메서드를 구현 VS 함수형 파라미터 필드 사용

혜택과 관련된 객체들을 생성하는 팩토리를 `enum`으로 구현하였습니다.
각각의 `enum` 상수들은 다음과 같은 정보들을 포함해야 했는데요.

- 날짜, 주문 목록을 확인하고 혜택을 적용할 수 있는지 확인
- 날짜, 주문 목록을 기준으로 혜택 생성

가장 자연스러운 것은 각각의 팩토리 `enum` 상수들이 필드로 조건을 판별할 수 있는 `BiPredicate`,
혜택 객체를 생성하기 위한 `BiFunction`을 가지는 것이 좋을 것이라 생각했습니다.
하지만, 필요 기능들을 람다 식으로 작성하고 나니 한 눈에 의도를 파악하기 어렵게 보였습니다.

이후 가독성을 위해 각 상수들이 내부에서 필요 메서드를 오버라이딩 하는 방법으로 변경하였습니다.
이제 각각의 코드를 보는 것에 있어서는 가독성이 좋아졌다고 생각이 드는데요.
대신, 전체적인 코드 라인이 많아지면서 불필요한 리팩토링을 한 것인가 라는 고민이 들었습니다.

여러분들은 어떤 방법이 더 좋을 것이라 생각하시나요?

### 출력 메서드의 파라미터 : 모델 객체 VS 원시값

우선, 이야기를 하기에 앞서, 저는 DTO를 사용하는 방법을 고려하지 않았습니다.
DTO를 사용하는 것은 모델과 출력의 책임을 더 확실하게 분리하고, 모델의 캡슐화를 보장해 주기 위해서라고 생각하는데요.
이번 과제에서는 DTO를 사용해야 할 만큼 출력의 책임을 갖는 부분에 모델이 넘어갔을 때의 위험이 존재하지 않는다고 생각했습니다.
오히려, 각각의 결과를 출력하기 위해 DTO를 생성하는 것이 오버 엔지니어링이라 느꼈고, 모델을 직접 사용하게 되었습니다.

저는 이후 출력 메서드에서 다른 값들을 추가로 출력해 주도록 요구사항이 변경될 것을 고려해 최대한 출력 메서드에 모델 객체를 직접 넘겨주었는데요.
메뉴의 이름 `String`과 주문 개수 `int`를 넘겨주는 대신, `MenuAndCount` 객체를 넘겨주는 식으로 접근했습니다.

이 때문에 출력의 책임을 갖는 메서드들은

1. 넘겨받은 객체에서 필요 데이터를 getter로 가져온다.
2. 해당 값을 사용해 출력 메시지를 구성 후 출력한다.
   처럼 객체에서 데이터를 추출하는 과정이 포함되었습니다.

만약 원시값을 넘겨준다면, 이후의 요구사항 변화에는 대응하기 더 힘들어 질 수 있겠지만,
출력 메서드는 확실하게 출력 메시지 생성이라는 하나의 관심사만 가질 수 있게 됩니다.

여러분들은 어떻게 구현하셨나요?

### InputView.hasNotMatchesPattern() 메서드는 더 좋은 접근 방법이 없을까?

해당 메서드는 입력받은 `List<String>`을 순회하면서 패턴에 맞지 않는 `String`이 존재하는지를 판단하기 위한 메서드입니다.
저는 아래와 같이 구현했는데요.

```java
public class InputView {
    Pattern orderMenuRegex = Pattern.compile("[가-힣]*-\\d*");

    private boolean hasNotMatchesPattern(List<String> orders) {
        return orders.stream()
                .map(orderMenuRegex::matcher)
                .dropWhile(Matcher::matches)
                .findAny()
                .isPresent();
    }
}
```

스트림 체인이 그닥 직관적이지 못하다는 생각이 듭니다.

더 좋은 방법은 없었을까요?

## 마치며

본 설명은 zangsu 님의 md 를 레퍼런스하였습니다.