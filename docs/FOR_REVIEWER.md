# 리뷰어 분들께

안녕하세요, 백엔드 6기 백엔드 지원자 jdohun 입니다.

리뷰어분들이 제 어플리케이션에 대해 쉽게 이해하고 보다 편하게 리뷰에 집중하실 수 있도록<br>
저의 어플리케이션에 대한 조금의 가이드를 드리고자 해당 글을 작성합니다.

## 디렉토리 구조

각각의 관심사와 형태 그리고 역할을 기준으로 책임을 분리하고, 각각의 책임에 따라 별도의 디렉토리를 부여하였습니다.

### 도메인

도메인 로직을 구분하는 기준은 `현실 문제에 대한 의사결정 여부` 입니다.

- 정보를 저장하고 현실 세계에 필요한 정보를 계산하는 기능 : `model`
    - 그 중에서도 `classes` 와 `enums` 로 구분

- 프로모션에 대한 관심 : `promotion`
    - 전략들을 사용 : `context`

    - 프로모션 전략들 : `strategy`
        - 날짜 확인
        - 총금액 확인
        - 할인 금액 계산

    - 비슷한 형태의 전략을 사용하는 `context`들을 관리하는 : `enums`

### DTO

- 단순히 값을 저장, 반환한다면 : `dto`
    - 따라서 현실 세계의 문제 미리보기에 필요한 프로모션 결과를 저장하지만</br>
      단순히 값을 반환하기만하는 `ChristmasPromotionPreview`은 미리보기 라는 현실 세계는 dto 에 속하게 됩니다.

### Parser

입력된 값의 형식을 검증함과 동시에 `model` 생성에 적절한 형태의 source 로 parsing 합니다.

### 입출력

- 입력을 위한 가이드 메시지 출력과 입력 값을 리턴의 책임을 갖는 `InputView`
    - 가장 기본적인 Input 에 대한 검증 기능을 가진 `InputValidator`
- 사용자의 입력과 별도로 필수 출력 메시지에 대한 책임을 갖는 `OutputView`
- 미리보기 출력에 대한 책임을 갖는 `Preview`
- 예외 처리된 IllegalArgumentException 의 정보를 출력하기 위한 `IllegalArgumentErrorView`

## 구현 관련 고민 목록

아래에는 제가 이번 어플리케이션을 구현하는 동안 해결하지 못했던 고민들입니다.</br>
참고하시어 편하게 의견을 주신다면 정말 감사하겠습니다!</br>
아래와 관련된 내용이 아니더라도 저의 코드에 대한 다양한 의견, 질문은 언제나 환영입니다!!!

### 함수형 인터페이스의 패키징 방법

공통된 기능을 추상화한 Interface 와 이를 구현한 클래스를 구분하기 위해</br>
공통 패키지 하위에 `impl`로 구분 지었지만</br>
함수형 인터페이스는 어디에 패키징 되어야 찾아보기 편할지 고민했습니다.</br>
단순히 util 로 묶어서 패키징 할 수도 있었겠지만</br>
util 로 묶은 기능들이 과연 진짜로 `util` 한 가? 에 대한 질문에 해답이 되지 않았습니다.

따라서 저는 추상화한 Interface 와 이를 구현한 클래스들을 가까이 두는 방식이 가장 적절하다고 생각하여</br>
구현 클래스들을 `impl`로 패키징 하고 상위 패키지에 인터페이스를 위치시켰습니다.</br>
하지만 이렇게 하다보니 억지로 상속시킨 `DateCheckStrategy`를 구현하면서 같은 코드가 반복되었습니다.</br>
`DayOfWeekCondition`의 경우는 이미 멤버로 `DateCheckStrategy`를 가지고 있기 때문에 중복되고</br>
`PeriodCondition`과 `SpecificDateCondition`은 `isSatisfyingCondition()`을 구현하면 충분하겠지만</br>
각각의 Condition 들의 dateCheck 방식이 미묘하게 다르기 때문에</br>
역할을 더 명확하게 드러내기 위해 따로 생성한 메소드를 다시 상속 오버라이드 메소드 내부에 위치시키는 불필요한 코드가 구현되버렸습니다.

`DiscountByDate` 와 `DateBasedDiscountStrategy` 의 패키징과 상속 역시 고민입니다.

만약 리뷰어분들은</br>
구현된 코드가 명확한 역할을 드러내는 메소드명을 유지하는 대신 상속 메서드 내부에 불필요한 코드를 작성</br>
vs 불필요하게 반복되는 코드를 줄이고 역할의 명확성 조금 흐릿해지더라도 단순 상속</br>
vs 아래와 같이 상속을 포기하고 메소드 내부에서 함수형 인터페이스의 메소드 구현임을 명시</br>

```
@Override
public boolean isPlanSatisfyingCondition(DecemberEventPlan decemberEventPlan) {
    DateCheckStrategy dateCheckStrategy = this::isDateWithinPeriod;
    return decemberEventPlan.isDateSatisfyingDateCondition(dateCheckStrategy);
}
```

세 가지 방법 중 어느 것을 추천하실까요?</br>
또한 상속을 포기하게 된다면 이 함수형 인터페이스들을 어떻게 패키징하는 것이 좋을까요?</br>
상속을 포기하지 않고도 다른 방식으로 패키징 할 수 있는 방법이 있을까요?</br>

### dto 인가? domain > model 인가?

"Data Transfer Object"의 약자</br>
단순히 데이터를 전달하는 객체라고 생각했기 때문에 앞서 설명한 것처럼</br>
똑같은 record 지만 어떤 것은 dto, 어떤 것은 domain > model 로 패키징하였는데요.</br>
사실 `현실 문제에 대한 의사결정 여부` 라는 기준을 생각해보자면</br>
`TotalBenefitAmount` : 총혜택 금액을 통해 부여할 뱃지를 결정하는데요</br>
내부를 살펴보면 단순히 amount 를 저장하고 있을 뿐 어떠한 기능도 없습니다.</br>

두 가지 기준 중 어느 것에 초점을 맞춰서 패키징하는 것을 선호하실까요?

### 테스트 구현

프로모션에 적용될 날짜 확인 전략, 할인 금액 계산 전략들은 모두 분리되어 구현되어 있고</br>
따라서 더욱 작은 단위로 테스트하기 용이했습니다.</br>

위 전략들이 문제없이 테스트를 통과했다면 구현된 전략을 사용하고 있는 context 는 테스트할 필요가 없는걸까요?</br>
각각의 기능을 통해 context 가 올바르게 기능하는지 테스트가 필요했을까요?</br>

사실 이번 복습과정이 꽤나 길어졌고 빨리 마무리하고 싶은 마음에 생략했지만 찝찝한 마음입니다.</br>

리뷰어분들의 의견은 어떠신지요?

### 오버엔지니어링

사실상 이번 복습 과정은 여러 지원자분들의 코드를 보며 새로 알게된 모든 지식을 모두 담으려고 노력했습니다.</br>
미션을 완성하는 것보다 `미션을 통한 학습`이 더 중요한 목표라고 생각했기 때문인데요.</br>
이 때문에 미션 자체는 굉장히 간단한 내용이지만 그에 비해 어플리케이션의 사이즈가 너무 커진 것 같습니다.</br>

만약 한번 더 복습한다면 어떤 부분을 위주로 사이즈를 줄여야할지 리뷰어분들의 도움이 필요합니다!</br>

## 마치며

대학교를 다니며 학습했지만 사실상 이번 미션을 통한 학습이 가장 저에게 남는 지식들이었던 것 같습니다.</br>
앞으로 어떠한 방향성을 가지고 학습해야할지 로드맵이 된 우테코 프리코스.</br>
비록 합격하진 못했지만 발판삼아 더욱 정진하겠습니다.</br>
감사합니다!

### p.s.

본 설명은 `zangsu` 님의 [FOR_REVIEWER.md](https://github.com/zangsu/java-christmas-6-zangsu/pull/22/files#diff-d4ea107e20a2eb0ed3b11c59686e3686e94e7d450c9bd0d1dabd85cf92ca7788)를 레퍼런스하였습니다.
